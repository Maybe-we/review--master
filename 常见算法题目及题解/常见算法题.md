

## 结构型模式

### 装饰者模式

#### 概述

【快餐店案例】
快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价格通常不太一样，那么计算总价就会显得比较麻烦。

使用继承的方式存在的问题：
- 扩展性不好
如果要再加一种配料（火腿肠），我们就会发现需要给 FriedBice 和 FriedNoodles 分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。
- 产生过多的子类

**定义：** 指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。

#### 结构

装饰模式中的角色：
- 抽象构件角色：定义一个抽象接口以规范准备接收附加责任的对象。
- 具体构件角色：实现抽象构件，通过装饰角色为其添加一些职责。
- 抽象装饰角色：继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
- 具体装饰角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

#### 案例

**好处：** 
- 装饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。
- 装饰类和被装饰类可以独立发展，不会相互耦合，装饰者模式是继承的一个替代模式，装饰者模式可以动态扩展一个实现类的功能。

#### 使用场景

- 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。
- 不能采用继承的情况主要用两类：
	- 第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；
	- 第二类是因为类定义不能继承（如 final 类）
- 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
- 当对象的功能要求可以动态地添加，也可以再动态地撤销时。

#### JDK 源码解析

IO 流中的包装类使用到了装饰者模式。BufferedInputStream，BufferedIOutputStream，BufferedReader，BufferedWriter。

我们以 BufferedWriter 举例说明：
>BufferedWriter 使用装饰者模式对 Writer 子实现类进行了增强，增加了缓冲区，提高了写数据的效率。

#### 代理和装饰者的区别

静态代理和装饰者模式的区别：
- 相同点：
	- 都要实现与目标类相同的业务借口
	- 在两个类中都要声明目标对象
	- 都可以在不修改目标类的前提下增强目标方法
- 不同点：
	- 目的不同
		- 装饰者是为了增强目标对象
		- 静态代理是为了保护和隐藏目标对象
	- 获取目标对象构建的地方不同
		- 装饰者是由外界传递进来，可以通过构造方法传递
		- 静态代理是在代理类内部创建，以此来隐藏目标对象

### 桥接模式

#### 概述

现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：

我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。
试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。

**定义：** 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

#### 结构

桥接模式包含以下角色：
- 抽象化角色：定义抽象类，并包含一个对实现化对象的引用。
- 扩展抽象化角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
- 实现化角色：定义实现化角色的接口，供扩展抽象化角色调用。
- 具体实现化角色：给出实现化角色接口的具体实现。

#### 案例

【视频播放器】
需要开发一个跨平台视频播放器，可以在不同操作系统平台（如 windows、mac、Linux 等）上播放多种格式的视频文件，常见的视频格式包括 RMVB、AVI、WMV 等。该播放器包含了两个维度，适合使用桥接模式。


>好处：
- 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。
如：如果现在还有一种视频文件类型 wmv，我们只需要再定义一个类实现 VideoFile 接口即可，其他类不需要发生变化。
- 实现细节对客户透明。

#### 使用场景
- 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。
- 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。
- 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系（主要是聚合关系）。

### 外观模式

#### 概述

有些人可能炒过股票，但其实大部分人都不太懂，在没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮手就好了，其实基金就是个好帮手。支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。

**定义：** 又称为**门面模式**，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统具体实现的细节，这样会大大降低应用程序的复杂度，提高程序的可维护性。

#### 结构

外观模式包含以下角色：
- 外观角色：为多个子系统对外提供一个共同的接口。
- 子系统角色：实现系统的部分功能，客户可以通过外观角色访问它。

#### 案例

【智能家电控制】
小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。

好处：
- 降低了子系统与客户端的耦合度，使得子系统的变化不会影响调用它的客户类。
- 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。
缺点：
- 不符合开闭原则，修改很麻烦。

#### 使用场景
- 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。
- 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。
- 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。

### 组合模式

#### 概述

对于这个图片肯定会非常熟悉，上图我们可以看作是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。

**定义：** 又称为整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

#### 结构

组合模式主要包含三种角色：
- 抽象根节点：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。
- 树枝节点：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点，形成一个树形结构。
- 叶子节点：叶子节点对象，其下再无分支，是系统各层次遍历的最小单位。

#### 案例

【软件菜单】
我们在访问一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。

#### 分类

在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。

- 透明组合模式
透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 `MenuComponent` 声明了 `add`、 `remove`、`getChild` 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。

透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 `add`、`remove` 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）。

- 安全组合模式
在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 `Menu` 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别的对待叶子构件和容器构件。

#### 优点

- 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。
- 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。
- 在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。
- 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。

#### 使用场景

组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。


# 行为型模式

## 策略模式

### 概述

如果我们去旅游，有多种出行方式供我们选择，可以骑自行车、可以坐汽车、可以坐火车、可以坐高铁。

作为一个程序员，开发需要选择一款开发工具，当然可以进行代码开发的工具有很多，可以选择 idea 进行开发，也可以使用 eclipse 进行开发，也可以使用其他的一些开发工具。

**定义：** 该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。

### 结构

策略模式的主要角色如下：
- 抽象策略类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色会给出所有的具体策略类所需要的接口。
- 具体策略类：实现了抽象策略定义的接口，提供具体的算法实现或行为。
- 环境类：持有一个策略类的引用，最终给客户端调用。

### 案例

【促销活动】
一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。

### 优缺点

优点：
- 策略类之间可以自由切换。
	由于策略类都实现同一个接口，所以使它们之间可以自由切换。
- 易于扩展。
	增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则”。
- 避免使用多重条件选择语句（if else），充分体现面向对象设计思想。
缺点：
- 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。
- 策略模式将产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。

### 使用场景

- 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。
- 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。
- 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。
- 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。
- 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。

## 命令模式

### 概述

我们在生活中可以遇到这种场景：点餐。顾客把订单给女招待。女招待拿了订单放到订单柜台，然后喊一声“订单来了”，厨师根据订单准备餐点。

**定义：** 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。

### 结构

命令模式包含以下主要角色：
- 抽象命令类角色：定义命令的接口，声明执行的方法。
- 具体命令角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。
- 实现者 / 接收者角色：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。
- 调用者 / 请求者角色：要求命令对象执行请求，通常会持有请求对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。

### 案例

【点餐】
将上面的案例用代码实现，我们分析命令模式的角色在该案例中由谁来充当。
服务员：就是调用者角色，由她来发起命令。
厨师：就是接收者角色，真正执行命令的对象。
订单：命令中包含订单。

### 优缺点

优点：
- 降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。
- 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。
- 可以实现宏命令。命令模式可以与组合模式相结合，将多个命令装配成一个组合命令，即宏命令。
- 方便实现 undo 和 redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。
缺点：
- 使用命令模式可能会导致某些系统有过多的具体命令类。
- 系统结构更加复杂。

### 使用场景
- 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。
- 系统需要在不同的时间指定请求、将请求排队和执行请求。
- 系统需要支持命令的撤销 undo 操作和恢复 redo 操作。

## 责任链模式

### 概述

在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如：公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签字，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。

**定义：** 又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。

### 结构

职责链模式主要包含以下角色：
- 抽象处理者角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
- 具体处理者角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
- 客户类角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。

### 案例

【请假流程控制系统】
现在需要开发一个请假流程控制系统。请假一天以下只需要小组长同意即可；请假 1 天到 3 天还需要部门经理同意；请假 3 天到 7 天还需要总经理同意才行。

### 优缺点

优点：
- 降低了对象之间的耦合度
	该模式降低了请求发送者和接收者的耦合度。
- 增强了系统的可扩展性
	可以根据需要增加的新的请求处理类，满足“开闭原则”。
- 增强了给对象指派职责的灵活性
	当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或删除责任。
- 责任链简化了对象之间的连接
	一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，者避免了 if 或者 if else 语句。
- 责任分担
	每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。
缺点：
- 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，该请求可能一直传递到链的末端都得不到处理。
- 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定的影响。
- 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。

### 使用场景

## 状态模式

### 概述

**定义：** 对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。

### 结构

状态模式主要包含以下角色：
- 环境角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。
- 抽象状态角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。
- 具体状态角色：实现抽象状态所对应的行为。





